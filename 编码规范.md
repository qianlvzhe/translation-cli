# Translation CLI 项目编码规范

本文档基于Monolith项目编码风格模板，结合Translation CLI项目的实际需求和技术栈特点，提供了全面的Rust编码规范指南。

## 项目概览

Translation CLI是一个高性能命令行HTML翻译工具，使用内置索引翻译技术，支持网页爬取、HTML处理、文本翻译和临时文件管理等功能。

## 项目结构与组织

### 目录结构
```
translation-cli/
├── Cargo.toml              # 项目配置文件
├── README.md               # 项目说明文档
├── src/                    # 核心源代码
│   ├── lib.rs             # 库入口文件，导出模块
│   ├── main.rs            # 可执行文件入口
│   ├── api_constants.rs   # API常量定义
│   ├── config.rs          # 配置管理模块
│   ├── html_processor.rs  # HTML处理模块
│   ├── stats.rs           # 统计功能模块
│   ├── temp_manager.rs    # 临时文件管理
│   ├── translator.rs      # 翻译核心功能
│   ├── utils.rs           # 通用工具函数
│   └── web_crawler.rs     # 网页爬取模块
├── tests/                 # 测试代码
│   ├── test_data/         # 测试数据
│   └── output/            # 测试输出
├── examples/              # 示例代码
└── target/                # 构建输出目录
```

### 模块组织原则
- 每个模块负责单一职责
- 使用`pub mod module_name`在lib.rs中导出模块
- 测试代码与源代码结构对应
- 功能模块按职责明确分离：配置、处理、翻译、爬取等

## Cargo.toml配置风格

### 项目元信息
```toml
[package]
name = "translation-cli"
version = "0.1.0"
edition = "2021"
description = "独立的高性能命令行HTML翻译工具，使用内置索引翻译技术"
authors = ["作者名称 <email@example.com>"]
homepage = "https://github.com/user/translation-cli"
repository = "https://github.com/user/translation-cli"
readme = "README.md"
keywords = ["translation", "html", "cli", "multilingual"]
categories = ["command-line-utilities", "internationalization"]
license = "MIT"
```

### 依赖管理
- **版本控制**: 使用语义化版本控制
- **特性控制**: 明确指定需要的特性
- **异步支持**: 使用tokio作为主要异步运行时

```toml
[dependencies]
# CLI构建
clap = { version = "4.0", features = ["derive"] }

# 异步运行时
tokio = { version = "1.42", features = ["full"] }
futures = "0.3"

# HTTP客户端
reqwest = { version = "0.12", features = ["json"] }
serde_json = "1.0"

# HTML处理
html5ever = "0.35"
markup5ever_rcdom = "0.35.0-unofficial"

# 错误处理
anyhow = "1.0"

# 日志系统
tracing = "0.1"
tracing-subscriber = "0.3"

# Web内容抓取
monolith = { version = "2.10.1", default-features = false }
```

### 库配置
```toml
[lib]
name = "translation_cli"
path = "src/lib.rs"
```

## 代码命名约定

### 命名规则
- **类型名称**: PascalCase (`TranslationConfig`, `WebCrawler`, `InputSource`)
- **函数名称**: snake_case (`translate_with_indexed_mode`, `validate_input_source`)
- **变量名称**: snake_case (`output_path`, `total_start`, `input_source`)
- **常量名称**: SCREAMING_SNAKE_CASE (`API_URL`, `BATCH_SIZE`, `DEFAULT_LANG`)
- **模块名称**: snake_case (`web_crawler`, `html_processor`, `temp_manager`)

### 语义化命名
- 使用描述性名称: `generate_output_path_for_source` 而不是 `gen_path`
- 布尔值使用is/has前缀: `is_url`, `has_extension`
- 动作使用动词: `translate_`, `validate_`, `init_`, `format_`
- 管理器类使用Manager后缀: `TempManager`
- 统计类使用Stats后缀: `TranslationStats`

### 类型定义风格
```rust
// 枚举定义
#[derive(Debug, Clone, PartialEq)]
pub enum InputSource {
    File(PathBuf),
    Url(String),
}

// 结构体定义
#[derive(Debug, Clone)]
pub struct TranslationConfig {
    pub lang: String,
    pub api_url: String,
    pub batch_size: usize,
    pub timeout: Duration,
}

// CLI参数结构
#[derive(Parser, Debug)]
#[command(name = "translation-cli")]
#[command(about = "高性能HTML翻译工具")]
pub struct Cli {
    /// 输入文件路径或URL
    pub input: String,
    
    /// 目标语言代码
    #[arg(short, long, default_value = "zh")]
    pub lang: String,
}
```

## 错误处理模式

### 统一错误处理
- 项目使用`anyhow`进行错误处理
- 函数返回`Result<T, anyhow::Error>`
- 使用`.context()`添加错误上下文

```rust
use anyhow::{Context, Result};

pub async fn translate_file(path: &Path) -> Result<String> {
    let content = fs::read_to_string(path)
        .context(format!("读取文件失败: {}", path.display()))?;
    
    // 处理逻辑
    Ok(processed_content)
}
```

### 错误处理策略
- 对于可恢复错误使用Result
- 使用`?`操作符进行错误传播
- 提供有意义的错误信息和上下文
- 避免不必要的`unwrap()`，优先使用错误处理

## 异步编程规范

### 异步函数定义
```rust
#[tokio::main]
async fn main() -> Result<()> {
    // 主函数逻辑
}

pub async fn async_function(param: Type) -> Result<ReturnType> {
    // 异步函数实现
}
```

### 异步最佳实践
- 使用`#[tokio::main]`标记main函数
- 异步函数使用`async fn`定义
- 使用`.await`等待异步操作
- 合理使用并发操作提高性能

## 日志记录规范

### 日志级别使用
```rust
use tracing::{info, warn, error, debug};

// 信息性日志
info!("🚀 启动HTML翻译 - 目标: 亚秒级性能");

// 警告日志  
warn!("⚠️ 检测到潜在问题: {}", issue);

// 错误日志
error!("❌ 操作失败: {}", error);

// 调试日志
debug!("🔍 调试信息: {:?}", debug_data);
```

### 日志格式规范
- 使用表情符号增强可读性
- 包含相关上下文信息
- 避免过度日志记录影响性能

## 模块可见性规则

### 公开接口设计
```rust
// 在lib.rs中导出模块
pub mod web_crawler;
pub mod temp_manager;
pub mod translator;
pub mod utils;
pub mod html_processor;

// 公开函数
pub async fn translate_with_indexed_mode(
    content: &str,
    config: &TranslationConfig,
) -> Result<String>

// 公开结构体
pub struct WebCrawler {
    client: reqwest::Client,
    pub config: CrawlerConfig,
}
```

### 可见性原则
- 最小化公开接口
- 仅导出必要的类型和函数
- 使用`pub(crate)`为内部可见性
- 私有字段优于公开字段

## 性能优化规范

### 内存管理
```rust
// 预分配容量
let mut results = Vec::with_capacity(expected_size);

// 使用引用避免克隆
fn process_data(data: &str) -> Result<String> {
    // 处理逻辑
}

// 适当使用Cow类型
use std::borrow::Cow;
fn maybe_owned(input: &str) -> Cow<str> {
    // 根据条件返回借用或拥有的数据
}
```

### 异步性能
- 使用并发处理提高性能
- 合理设置批处理大小
- 避免不必要的异步边界

## 测试代码风格

### 测试模块组织
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;
    
    #[tokio::test]
    async fn test_translation_functionality() {
        // 测试逻辑
        let result = translate_text("Hello").await;
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_synchronous_function() {
        // 同步测试逻辑
        assert_eq!(expected, actual);
    }
}
```

### 测试命名和结构
- 测试函数以`test_`开头
- 使用描述性测试名称
- 异步测试使用`#[tokio::test]`
- 同步测试使用`#[test]`

## 文档注释风格

### 文档注释使用
```rust
//! 模块级别文档注释
//! 
//! 描述模块的功能和用途

/// 函数或类型的文档注释
/// 
/// # Arguments
/// 
/// * `param` - 参数描述
/// 
/// # Returns
/// 
/// 返回值描述
/// 
/// # Errors
/// 
/// 可能出现的错误情况
pub fn documented_function(param: &str) -> Result<String> {
    // 实现
}
```

### CLI参数文档
```rust
/// 输入文件路径或URL
#[arg(help = "要翻译的HTML文件路径或网页URL")]
pub input: String,

/// 目标语言代码
#[arg(short, long, default_value = "zh", help = "翻译目标语言 (如: zh, en, ja)")]
pub lang: String,
```

## 代码格式化标准

### 导入语句组织
```rust
// 标准库导入
use std::fs;
use std::path::{Path, PathBuf};
use std::time::{Duration, Instant};

// 第三方crate导入
use anyhow::{Context, Result};
use clap::Parser;
use tokio::fs as async_fs;
use tracing::{info, error, warn};

// 本地模块导入
use crate::config::{Cli, TranslationConfig};
use crate::utils::{validate_input_source, InputSource};
```

### 函数定义风格
```rust
pub async fn async_function_with_multiple_params(
    param1: &str,
    param2: usize,
    config: &TranslationConfig,
) -> Result<String> {
    // 函数体
}
```

## 特定模式和约定

### 配置管理模式
```rust
#[derive(Debug, Clone)]
pub struct TranslationConfig {
    pub lang: String,
    pub api_url: String,
    pub batch_size: usize,
}

impl Default for TranslationConfig {
    fn default() -> Self {
        Self {
            lang: "zh".to_string(),
            api_url: get_api_url(),
            batch_size: get_batch_size(),
        }
    }
}
```

### 临时文件管理模式
```rust
pub struct TempManager {
    temp_dir: PathBuf,
}

impl TempManager {
    pub fn new() -> Result<Self> {
        // 初始化逻辑
    }
    
    pub fn create_temp_file(&self, suffix: &str) -> Result<PathBuf> {
        // 创建临时文件
    }
}

impl Drop for TempManager {
    fn drop(&mut self) {
        // 清理资源
    }
}
```

### 性能统计模式
```rust
#[derive(Debug)]
pub struct TranslationStats {
    pub total_time: Duration,
    pub translation_time: Duration,
    pub characters_processed: usize,
}

impl TranslationStats {
    pub fn chars_per_second(&self) -> f64 {
        self.characters_processed as f64 / self.total_time.as_secs_f64()
    }
}
```

## 安全性规范

### 输入验证
- 验证所有外部输入
- 清理和转义用户数据
- 使用类型系统确保安全性

### 文件操作安全
```rust
use std::path::Path;

pub fn safe_file_operation(path: &Path) -> Result<()> {
    // 验证路径安全性
    if !path.exists() {
        return Err(anyhow!("文件不存在: {}", path.display()));
    }
    
    // 安全操作
    Ok(())
}
```

## 编码最佳实践

### 代码组织
1. 保持函数简洁，单一职责
2. 使用有意义的中间变量
3. 适当的代码分层和模块化
4. 避免深度嵌套

### 可维护性
- 清晰的模块边界
- 最小化模块间依赖
- 一致的错误处理策略
- 充分的测试覆盖

### 性能考虑
- 合理使用异步并发
- 避免不必要的内存分配
- 使用适当的数据结构
- 考虑缓存策略

---

## 使用指南

当开发Translation CLI代码时，请确保：

1. **遵循命名约定**: 使用snake_case和PascalCase
2. **模块化设计**: 功能相关代码组织在同一模块
3. **异步优先**: 合理使用异步编程提高性能
4. **错误处理**: 使用anyhow和Result类型
5. **日志记录**: 提供有意义的日志信息
6. **测试覆盖**: 为新功能添加对应测试
7. **文档注释**: 为公开API提供清晰文档
8. **性能优化**: 考虑内存使用和执行效率
9. **安全性**: 验证输入，安全处理文件操作

这个编码规范结合了Monolith项目的成熟模式和Translation CLI项目的具体需求，旨在确保代码质量、可维护性和性能。